from .mt_tools import MtTools, Encode


class MerkleTree:
    """
    Usage of MerkleTree:
        - Create an instance in a Node(e.g: Full-Node) - node.mt = MerkleTree()
        - Update the Tree with new data - node.mt.update_tree(hash("New Post")) or
                                          node.mt.update_tree("New Post", True) or
                                          node.mt.update_tree(["First Post", "Second Post"], True)
                                          node.mt.update_tree([hash("First Post"), hash("Second Post"]))
        - Reset tree: node.mt.reset_tree()
        - Print the three: node.mt.print_tree()
        - Get merkle root : node.mt.get_merkle_root()
        - Get the proof_hashes (Path to the merkle root) at a specific index - node.mt.get_proof_by_index(3)
    """
    def __init__(self):
        """
            hash_function: Ideally, could pass a param 'hash_function' to the merkle tree to get the adapted hash func.
            leaves: Leaves of the tree, messages for Infnote.
            tree: Contain the tree levels within a double dimension array
            is_built: Used to check the status of the tree. True is the tree is update with the last inserted leaves.
        """
        self.leaves = list()
        self.tree = []
        self.is_built = False
        self.hash_function = Encode.sha256

    def reset_tree(self):
        """
        Reset the tree, clear the leaves and the tree.
        :return: void
        """
        self.leaves = list()
        self.tree = None
        self.is_built = False

    def update_tree(self, values, hash_it=False):
        """
        To update the tree by inserting new data. Add a leaf and build the tree with the updated data.
        :param values: This is the new data to insert into the tree, can be a list or a string
        :param hash_it: The previous data can be already of or not. If you need to hash new data, hash_it is True.
        By default, hash_it will be set to False as we consider that the Hash of a Block is already compute.
        :return: void
        """
        self.add_leaf(values, hash_it)
        self.build_tree()

    def add_leaf(self, values, hash_it=False):
        """
        To add a new leaf in the tree, this method should be followed by "build_tree", otherwise the new data
        will not be considered in the built tree.
        :param values: This is the new data to insert into the tree, can be a list or a string
        :param hash_it: The previous data can be already of or not. If you need to hash new data, hash_it is True.
        By default, hash_it will be set to False as we consider that the Hash of a Block is already compute.
        :return: void
        """
        self.is_built = False
        # Transform the single leaf in a list
        if not isinstance(values, tuple) and not isinstance(values, list):
            values = [values]
        for v in values:
            # If data is not hashed yet
            if hash_it:
                v = self.hash_function(v)
            self.leaves.append(v)

    def get_hash_function(self):
        """
        Get the hash_function associated to this instance of the merkle tree. Ideally will be generated by a factory
        in tools
        :return: hash_function initialized in the class constructor
        """
        return self.hash_function

    def get_sibling_value(self, level, index):
        """
        Get the sibling value based on the precise index in the double dimensions array
        :param level: index of the first dimension of the tree. Basically giving the height where the sibling is.
        :param index: index of the leaf in the specific level (previous argument)
        :return: Value of the sibling in the tree.
        """
        sibling_value = self.tree[level][MtTools.get_sibling_index(index)]
        return sibling_value

    def get_leaf_nbr(self):
        """
        Get the number of leaves; Messages for Infnote
        :return: Number of leaves
        """
        return len(self.leaves)

    def _get_new_level(self, solo_leaf, last_height, nbr_leaves_lvl):
        """
        Function called within tree creation or update. It is appending the new hashes from parent nodes in the level.
        :param solo_leaf: In case of odd leaves number, we are promoting the solo node to this new level.
        :param last_height: The last level in this tree. This is the parent level of our new_level.
                            We are extracting pair of leaves from this level.
        :param nbr_leaves_lvl: Number of leaves on this specific level / Height in the tree.
        :return: The new created level filled with children of pairs from last height.
        """
        new_level = []
        # Group two nodes, the two futures parents
        print("last_height before:"+str(last_height))
        for left, right in zip(last_height[0:nbr_leaves_lvl:2], last_height[1:nbr_leaves_lvl:2]):
            new_level.append(self.hash_function(left + right))
        if solo_leaf is not None:  # promote the solo leaf to the next level.
            new_level.append(solo_leaf)
        return new_level

    def _create_next_height(self):
        """
        Function to create every level of the tree based on the last level of the tree.
        Create_next_height should be call until the merkle_root / digest is not reached.
        The merkle root is reached when size of self.tree equals 1.
        :return: void
        """
        solo_leaf = None
        last_height = self.tree[0]
        nbr_leaves_lvl = len(last_height)  # number of leaves on the level
        if nbr_leaves_lvl % 2 == 1:
            # if odd number of leaves on the level;
            # We are storing solo leaf to promote it to the next level, we decrease number of leaves for current level.
            solo_leaf = last_height[-1]
            nbr_leaves_lvl -= 1
        new_height = self._get_new_level(solo_leaf, last_height, nbr_leaves_lvl)
        self.tree = [new_height, ] + self.tree  # append in front the new level.

    def build_tree(self):
        """
        Build the tree based on the last inserted leaves. Data will be pushed to tree which is a double dimension list.
        First dimension is the levels and Second dimension is data within a specific level.
        :return: void
        """
        self.is_built = False
        if self.get_leaf_nbr() > 0:
            # Push the last added leaves to the tree.
            self.tree = [self.leaves, ]
            print("Leaves: " + str(self.leaves))
            # Creating the children for each level until root is reached
            while len(self.tree[0]) > 1:
                self._create_next_height()
        print("-----")
        print("Final Height :"+str(self.tree))
        print("-----")
        self.is_built = True

    def get_merkle_root(self):
        """
        Get the merkle root of the tree
        :return: merkle root which is the first element of the first dimenson of the tree
        """
        if self.is_built:
            if self.tree is not None:
                return self.tree[0][0]
            return None
        return None

    def get_leaf_by_index(self, index):
        """
        Get the leaf based on the index
        :param index: Index of the searched leaf
        :return: return the leaf value based on the index.
        """
        return self.leaves[index]

    def _check_valid_search(self, index):
        if self.tree is None:
            return False
        elif not self.is_built or index > len(self.leaves) - 1 or index < 0:
            return False
        return True

    def get_proof_by_index(self, index):
        """
        Get the path needed to validate the merkle root.
        :param index: Index of the leaf, the n^th message.
        :return: proof_hashes is an array containing a map indicating a leaf value and if it left or right.
        """
        if not self._check_valid_search(index):
            return None
        proof_hashes = []
        index_on_lvl = index
        for level in range(len(self.tree) - 1, 0, -1):
            height_len = len(self.tree[level])
            if MtTools.is_odd_end_node(index_on_lvl, height_len):
                index_on_lvl = int(index_on_lvl / 2.)
                continue
            proof_hashes.append({MtTools.get_sibling_pos(index_on_lvl): self.get_sibling_value(level, index_on_lvl)})
            index_on_lvl = int(index_on_lvl / 2.)
        return proof_hashes

    def print_tree(self):
        """
        Print the merkle tree
        :return: void
        """
        print("/ Print Tree /")
        leaves_nbr = self.get_leaf_nbr()
        print("We have :" + str(leaves_nbr) + " leaves in the tree")
        cnt = 0
        while cnt < leaves_nbr:
            print("leaf(" + str(cnt) + ")_value = " + str(self.get_leaf_by_index(cnt)))
            cnt += 1
        for x in range(0, len(self.tree), +1):
            if x == len(self.tree) - 1:
                print("--- Leaves level{"+str(x)+"}:"+str(self.tree[x]))
            else:
                print("--- Branch level{" + str(x) + "}:" + str(self.tree[x]))
        if self.is_built:
            print("Tree is ready and has been built")
            root_value = self.get_merkle_root()
            print("Digest of the tree:" + str(root_value))
        else:
            print("Tree is not ready and has not been built, So no digest")
